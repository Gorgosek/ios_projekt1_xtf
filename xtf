#!/bin/bash

POSIXLY_CORRECT=yes

if [[ $# -eq 0 ]]; then
    echo "Needed arguments missing!"
    echo "Use -h, --help to display usage."
    exit 1
fi

# OPTS: -h | --help, FILTR: -a DATETIME(after), -b DATETIME(before)
# PRIKAZ: list USER 

# Functions

function print_help() {
    echo "Usage: $0 [-h |--help] [FILTR] [PRIKAZ] UZIVATEL LOG [LOG2 [...]]"
    echo ""
    echo ""
    echo "Options:"
    echo "  -h, --help      Display this help and exit"
    echo "  FILTR           Use of the -a -b -c flags to filter out the desired output"
    echo "    -a DATETIME     Filter to find rows after a timestamp DATETIME format = YYYY-MM-DD HH:MM:SS"
    echo "    -b DATETIME     Filter to find rows before a timestamp DATETIME format = YYYY-MM-DD HH:MM:SS"
    echo "    -c CURRENCY     Filter to find rows corresponding to trades using CURRENCY format = 3 letter names (ex. ETH, BTC..)"
    echo "  UZIVATEL        A continuous string value representing the username"
    echo "  LOG, LOG2, ...  Plain text files [can also be comprimed .gz] without specified suffix ('.*')"
    echo ""
}

# TODO fix getopts not working when uzivatel infront of option either :/

function print_error(){
    echo "$1" >&2
    if [[ "$2" -ne 0 ]]; then
        exit "$2"
    fi
}

# Checks subshell for exit status and exits
function throw_error(){
    error="$?"
    if [[ "$error" != "0" ]]; then
        exit "$error"
    fi
}

function check_datetime(){
    if [[ -z "$1" ]]; then
        print_error "Field date not specified." 1
        echo ""
        return 1
    fi

    local DATETIME
    local format

    DATETIME="$1"
    format=$(date -d "$DATETIME" "+%Y-%m-%d %H:%M:%S" 2>/dev/null)

    if [[ -z "$format" ]]; then
        print_error "Invalid date. Use a correct date or get help via -h or --help" 1
        echo ""
        return 1
    else
        echo "$format"
        return 0
    fi
}

function make_timestamp(){
    VAR="$1"
    awk -v var="$VAR" 'BEGIN{if(var != "") output=mktime(gensub(/[-:]/, "  ", "g", var)); else output=-1;print output}'
}

# TODO create functions for each of the options then combine them using | and solve for all
# JMENO UZIVATELE;DATUM A CAS;MENA;HODNOTA
XTF_PROFIT=0.2

function awk_list ()
{
    USERNAME="$1"
    LOGFILE="$2"
    if [[ "$LOGFILE" == *.gz ]]; then
        gunzip -c "$LOGFILE" | awk -F';' -v uziv="$USERNAME" '$1 == uziv {print $0}'        
    else
        awk -F';' -v uziv="$USERNAME" '$1 == uziv {print $0}' "$LOGFILE" 
    fi
}

# TODO man awk /mktime for timestamp conversion
function apply_filters(){
    INPUT="$1"
    CHOSEN_CURRENCY="$2"
    echo "$INPUT" | awk -F';' -v curr="$CHOSEN_CURRENCY" -v a="$(make_timestamp "$after")" -v b="$(make_timestamp "$before")" -v c="$CHOSEN_CURRENCY" '
    BEGIN{ 
        t=0;
        throwAway=0;
    } 
    {
        t=mktime(gensub(/[-:]/, "  ", "g", $2));

        if(a != -1){
            if(t>a){
                throwAway=0;
            } else {
                throwAway=1;
                next;
            }
        } else{
            throwAway=0;
        }

        if(b != -1){
            if(t<b){
                throwAway=0;
            } else {
                throwAway=1;
                next;
            }
        } else{
            throwAway=0;
        }

        if(c != ""){
            if(c == $3){
                throwAway=0;
            } else {
                throwAway=1;
                next;
            }
        } else{
            throwAway=0;
        }

        if(throwAway != 1){
            print $0;
        }
        
    }'
}

function awk_list_currency ()
{
    FILTERED_INPUT="$1"
    echo "$FILTERED_INPUT" | awk -F';' '{print $3}'| uniq | sort -d
}

function sanitize_blank_lines(){
    echo "$1" | awk NF
}

function awk_status()
{
    FILTERED_INPUT="$1"
    CHOSEN_CURRENCY="$2"
    echo "$FILTERED_INPUT" | awk -F';' -v curr="$CHOSEN_CURRENCY" '$3 == curr {sum+=$NF} END {printf "%s : %.4f\n", curr, sum}'
}

function awk_profit()
{
    FILTERED_INPUT="$1"
    CHOSEN_CURRENCY="$2"
    echo "$FILTERED_INPUT" | awk -F';' -v curr="$CHOSEN_CURRENCY" -v prof=$XTF_PROFIT '{
        if ($3 == curr) {
            if ($NF > 0) {
                sum += ($NF * (1 + prof))
            } else {
                sum += $NF
            }
        }
    } END {
        printf "%s : %.4f\n", curr, sum
    }'
}

# Variables
args="$*"
uzivatel=""
logs=()
datetimeB=""
datetimeA=""
currency=()

# Display help and exit, ignore all the other arguments
if [[ "$args" == *"--help"* || "$args" == *"-h"* ]]; then
    print_help
    exit 0
fi

after=""
before=""

# Set variables based on arguments
while getopts ":a:b:c:" opt; do
    case "${opt}" in
        a) 
            if [[ -n "$datetimeA" ]]; then
                print_error "Invalid -a flag use" 1
            fi
            datetimeA="$OPTARG"
            after=$(check_datetime "$datetimeA")
            ;;
        b) 
            if [[ -n "$datetimeB" ]]; then
                print_error "Invalid -b flag use" 1
            fi
            datetimeB="$OPTARG"
            before=$(check_datetime "$datetimeB")
            ;;
        c) 
            currency+=("$OPTARG")
            ;;
        \?) 
            echo "Invalid arguments specified - $OPTARG"
            exit 1
            ;;
    esac
done

# Throws an error if check_datetime exits with 1
throw_error 

shift $((OPTIND -1))

option_count=0
selected_option=""

for option in "$@"; do
    case "$option" in
        list | list-currency | status | profit)
            selected_option="$option"
            ((option_count++))
            if [[ "$option_count" -gt 1 ]]; then
                print_error "Too many options selected chose only one!" 1
            fi
            shift
            ;;
    esac
done


if [[ "$selected_option" == "" && "$option_count" -eq 0 ]]; then
    selected_option="list"
fi

for arg in "$@"; do 
    if [[ -f "$arg" ]]; then
        logs+=("$arg")
    else
        if [[ -n "$uzivatel" ]]; then
            echo "Too many non-file arguments $*"
            exit 1
        else
            uzivatel="$arg"
        fi
    fi
done

# Put awk_list output into $result
result=""
for log in "${logs[@]}"; do 
    result+="$(awk_list "$uzivatel" "$log")"
    result+=$'\n'
done
result="$(sanitize_blank_lines "$result")"


# Apply filters
prev_result="$result"
result=""
if [[ -n $prev_result ]]; then
    if [[ ${#currency[@]} -eq 0 ]]; then
        result+="$(apply_filters "$prev_result" "")"
    else
        for crypto in "${currency[@]}"; do
            result+="$(apply_filters "$prev_result" "$crypto")"
            result+=$'\n'
        done
    fi
fi
result="$(sanitize_blank_lines "$result")"
    
# Use functions to display final filtered output
case "$selected_option" in
    list)
        echo "$result"
        ;;
    list-currency) 
        awk_list_currency "$result"
        ;;
    status)
        # For each currency found using awk_list_currency
        while IFS= read -r curr; do
            awk_status "$result" "$curr"
        done <<< "$(awk_list_currency "$result")"
        ;;
    profit)
        # For each currency found using awk_list_currency
        while IFS= read -r curr; do
            awk_profit "$result" "$curr"
        done <<< "$(awk_list_currency "$result")"
        ;;
esac


