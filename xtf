#!/bin/bash

POSIXLY_CORRECT=yes

if [[ $# -eq 0 ]]; then
    echo "Needed arguments missing!"
    echo "Use -h, --help to display usage."
    exit 1
fi

# OPTS: -h | --help, FILTR: -a DATETIME(after), -b DATETIME(before)
# PRIKAZ: list USER 

# Functions

function print_help() {
    echo "Usage: $0 [-h |--help] [FILTR] [PRIKAZ] UZIVATEL LOG [LOG2 [...]]"
    echo ""
    echo ""
    echo "Options:"
    echo "  -h, --help      Display this help and exit"
    echo "  FILTR           Use of the -a -b -c flags to filter out the desired output"
    echo "    -a DATETIME     Filter to find rows after a timestamp DATETIME format = YYYY-MM-DD HH:MM:SS"
    echo "    -b DATETIME     Filter to find rows before a timestamp DATETIME format = YYYY-MM-DD HH:MM:SS"
    echo "    -c CURRENCY     Filter to find rows corresponding to trades using CURRENCY format = 3 letter names (ex. ETH, BTC..)"
    echo "  UZIVATEL        A continuous string value representing the username"
    echo "  LOG, LOG2, ...  Plain text files [can also be comprimed .gz] without specified suffix ('.*')"
    echo ""
}

function print_error(){
    echo "$1" >&2
    if [[ "$2" -ne 0 ]]; then
        exit "$2"
    fi
}

# Checks subshell for exit status and exits
function throw_error(){
    error="$?"
    if [[ "$error" != "0" ]]; then
        exit "$error"
    fi
}

function check_datetime(){
    if [[ -z "$1" ]]; then
        print_error "Field date not specified." 1
        echo ""
        return 1
    fi

    local DATETIME
    local format

    DATETIME="$1"
    format=$(date -d "$DATETIME" "+%Y-%m-%d %H:%M:%S" 2>/dev/null)

    if [[ -z "$format" ]]; then
        print_error "Invalid date. Use a correct date or get help via -h or --help" 1
        echo ""
        return 1
    else
        echo "$format"
        return 0
    fi
}

# Variables
args="$*"
uzivatel=""
logs=()
datetimeB=""
datetimeA=""
currency=""

# Display help and exit, ignore all the other arguments
if [[ "$args" == *"--help"* || "$args" == *"-h"* ]]; then
    print_help
    exit 0
fi

after=""
before=""

# Set variables based on arguments
while getopts ":a:b:c:" opt; do
    case "${opt}" in
        a) 
            datetimeA="$OPTARG"
            after=$(check_datetime "$datetimeA")
            ;;
        b) 
            datetimeB="$OPTARG"
            before=$(check_datetime "$datetimeB")
            ;;
        c) 
            currency="$OPTARG"
            ;;
        \?) 
            echo "Invalid arguments specified - $OPTARG"
            exit 1
            ;;
    esac
done

# Throws an error if check_datetime exits with 1
throw_error 

shift $((OPTIND -1))

option_count=0
selected_option=""

for option in "$@"; do
    case "$option" in
        list | list-currency | status | profit)
            selected_option="$option"
            ((option_count++))
            shift
            ;;
        *)
            if [[ "$option_count" -gt 1 ]]; then
                print_error "Too many options selected chose only one!" 1
            fi
            ;;
    esac
done


if [[ "$selected_option" == "" && "$option_count" -eq 0 ]]; then
    selected_option="list"
fi

for arg in "$@"; do 
    if [[ -f "$arg" ]]; then
        logs+=("$arg")
    else
        if [[ -n "$uzivatel" ]]; then
            echo "Too many non-file arguments $*"
            exit 1
        else
            uzivatel="$arg"
        fi
    fi
done

for log in "${logs[@]}"; do 
    case "$selected_option" in
        list)
            awk -F';' -v uziv="$uzivatel" '$1 == uziv {print $0}' "$log" 
            ;;
        list-currency) 
            awk -F';' -v uziv="$uzivatel" -v cur="$currency" '$1 == uziv && $ {print $0}' "$log" | sort -t';' -k3,3
            ;;
        status)
            ;;
        profit)
            ;;
        *) echo default
            ;;
    esac
done


echo "Uzivatel: $uzivatel"
echo "Files:"
for file in "${logs[@]}"; do
    echo "$file"
done

echo ""
echo "ALL ARGS, VARS"

echo "-a $after -b $before -c $currency option: $selected_option"

echo "$# num; , $*"



